<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />


<meta name="author" content="Joao Goncalves" />

<meta name="date" content="2017-11-25" />

<title>P5 Spatial data analysis: introduction to raster processing (part-4)</title>

<script src="P5_rasterPackageIntroduction_IV-v1_files/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="P5_rasterPackageIntroduction_IV-v1_files/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="P5_rasterPackageIntroduction_IV-v1_files/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="P5_rasterPackageIntroduction_IV-v1_files/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="P5_rasterPackageIntroduction_IV-v1_files/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="P5_rasterPackageIntroduction_IV-v1_files/navigation-1.1/tabsets.js"></script>
<link href="P5_rasterPackageIntroduction_IV-v1_files/highlightjs-1.1/default.css" rel="stylesheet" />
<script src="P5_rasterPackageIntroduction_IV-v1_files/highlightjs-1.1/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>



<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->






<div class="fluid-row" id="header">



<h1 class="title toc-ignore">P5 Spatial data analysis: introduction to raster processing (part-4)</h1>
<h4 class="author"><em>Joao Goncalves</em></h4>
<h4 class="date"><em>25 November 2017</em></h4>

</div>


<div id="background" class="section level3">
<h3>Background</h3>
<hr />
<p>In the fourth part of this tutorial series on spatial data analysis using the <code>raster</code> package, we will explore more functionalities, this time related to time-series analysis of raster data.</p>
<p>We will use an Enhanced Vegetation Index (<a href="https://en.wikipedia.org/wiki/Enhanced_vegetation_index">EVI</a>) 5-year time-series (from year 2012 to 2016) from Terra/MODIS satellite/sensor platform for the Peneda-Geres National Park (PGNP, in NW Portugal) to develop some examples.</p>
<p>This data corresponds to MODIS‚Äôs <strong>MOD13Q1 data product</strong> version-006 (<a href="https://lpdaac.usgs.gov/dataset_discovery/modis/modis_products_table/mod13q1_v006">+info here</a>) which has 250m of spatial resolution and, 16-days of temporal resolution (more precisely, the product is generated by maximum daily value composites for each 16-day period). This means that each year has a total of 23 observations. These data was downloaded from the <a href="https://search.earthdata.nasa.gov/search">EarthData</a> platform and later assembled and reprojected to WGS 1984 - UTM 29N Coordinate Reference System (CRS) using MODIS Reprojection Tool - MRT (sorry but these pre-processing steps are outside the scope of this tutorial üòÅ).</p>
<p>In this post we will introduce <code>RasterBrick</code>s, a multi-layer raster object typically created from a multi-layer (or multi-band) file although they can also exist entirely in memory. These objects are similar to <code>RasterStack</code>s, but processing time should be shorter when using a <code>RasterBrick</code> (irrespective if values are on disk or in memory). However these objects are less flexible as they can only point to a single file, while <code>RasterStacks</code> can point to multiple different files.</p>
<p>Besides the <code>raster</code> package we will also work with <code>rts</code>, which provides classes and methods for manipulating and processing raster time-series data (e.g.¬†a time-series of satellite images). A raster time-series object is created by combining a <code>RasterStack</code> or <code>RasterBrick</code> object (from <code>raster</code> package) and a set of dates of class <code>POSIXct</code>, <code>POSIXt</code>, <code>Date</code>, <code>timeDate</code>. The time information in <code>rts</code> is then handled by a <code>xts</code> object.<br />
The function <code>rts</code> is used to build a raster time-series (either a <code>RasterBrickTS</code> or <code>RasterStackTS</code>) which is simply a S4 object composed by two slots:</p>
<ul>
<li>slot [<em>raster</em>]: a <code>RasterStack</code> or <code>RasterBrick</code> object;</li>
<li>slot [<em>time</em>]: a <code>xts</code> object with dates for each layer in the raster object.</li>
</ul>
<p>One key advantage of using <code>rts</code> package is to facilitate the subset, extraction or application of functions by specific periods using date notation (instead of integer or name indices like in <code>raster</code>).</p>
<p>For more information on raster data processing see <a href="http://r-exercises.com/tags/raster-data">here</a>, as well as the <a href="https://www.r-exercises.com/2017/11/29/spatial-data-analysis-introduction-to-raster-processing-part-1">tutorial part-1</a>, <a href="https://www.r-exercises.com/2017/12/13/spatial-data-analysis-introduction-to-raster-processing-part-2">tutorial part-2</a>, and, <a href="https://www.r-exercises.com/2018/01/10/spatial-data-analysis-introduction-to-raster-processing-part-3">tutorial part-3</a>, of this series.</p>
</div>
<div id="making-a-raster-time-series-object-with-rts-package" class="section level3">
<h3>Making a raster time-series object with rts package</h3>
<hr />
<p>First up: download and uncompress the sample data! üëç The .zip archive contains a multi-layer GeoTIFF file with a 16-day (composite) EVI time-series from 2012 to 2016. This means that we have a total of 23 images per year and a total of 115 layers in the file (for the whole five-year series).</p>
<pre class="r"><code>## Create a folder named data-raw inside the working directory to place downloaded data
if(!dir.exists(&quot;./data-raw&quot;)) dir.create(&quot;./data-raw&quot;)

## If you run into download problems try changing: method = &quot;wget&quot;
download.file(&quot;https://raw.githubusercontent.com/joaofgoncalves/R_exercises_raster_tutorial/master/data/MODIS_EVI_TS_PGNP_MultiBand.zip&quot;, &quot;./data-raw/MODIS_EVI_TS_PGNP_MultiBand.zip&quot;, method = &quot;auto&quot;)

## Uncompress the zip file
unzip(&quot;./data-raw/MODIS_EVI_TS_PGNP_MultiBand.zip&quot;, exdir = &quot;./data-raw&quot;)</code></pre>
<p>Creating the <code>RasterBrick</code> from the downloaded data is really easy and similar to using the <code>stack</code>. The main advantage is that the input is just one multi-layer file, instead of a vector with multiple files as usually when using <code>stack</code>. We will also change the names of each layer for making them more readable. Let‚Äôs see how this goes:</p>
<pre class="r"><code>library(raster)

# Load the raster data into a RasterBrick object
rst &lt;- brick(&quot;./data-raw/MOD13Q1.2012_2016.PGNP_250m_EVI_16days.tif&quot;)

names(rst) &lt;- paste(&quot;EVI&quot;,1:nlayers(rst),sep=&quot;_&quot;)</code></pre>
<p>MODIS data products such as <em>MOD13Q1</em> (and others alike) use 7-digit long dates composed by the year (4 digits) followed by the Julian day (3 digits) to identify the reference date of an image composite. For example the date code 2012001 corresponds to 2012-01-01 (in YYYY-mm-dd format), and, 2012161 to 2012-06-09. Usually these dates are inscribed in image files or metadata but, since we don‚Äôt have them, we will generate them first and then process them so we can obtain a <code>Date</code> object for each layer. We can then use these properly formatted dates in the <code>rts</code> function to create a raster time-series (see <code>?rts</code> for more details).</p>
<pre class="r"><code>padIt &lt;- function(x) 
  if(x&lt;10) paste(&quot;00&quot;,x,sep=&quot;&quot;) else if(x&lt;100 &amp; x&gt;=10) paste(&quot;0&quot;,x, sep=&quot;&quot;) else return(as.character(x))

padWithZeros &lt;- function(x) 
  sapply(x, FUN = padIt) 

# Generate the MODIS-like dates for each layer
julDay &lt;- padWithZeros(rep(seq(from = 1,to = 365,by = 16),5))
yrs &lt;- as.character(rep(2012:2016, each = 23))
MODISYrJday &lt;- paste(yrs, julDay, sep=&quot;&quot;)

# Print out the MODIS dates for the year 2012
print(MODISYrJday[1:23])</code></pre>
<pre><code>##  [1] &quot;2012001&quot; &quot;2012017&quot; &quot;2012033&quot; &quot;2012049&quot; &quot;2012065&quot; &quot;2012081&quot; &quot;2012097&quot;
##  [8] &quot;2012113&quot; &quot;2012129&quot; &quot;2012145&quot; &quot;2012161&quot; &quot;2012177&quot; &quot;2012193&quot; &quot;2012209&quot;
## [15] &quot;2012225&quot; &quot;2012241&quot; &quot;2012257&quot; &quot;2012273&quot; &quot;2012289&quot; &quot;2012305&quot; &quot;2012321&quot;
## [22] &quot;2012337&quot; &quot;2012353&quot;</code></pre>
<p>Now that we have our MODIS-like dates (in year and Julian day format) we need to convert them into a more ‚Äòhuman-readable‚Äô format also accepted by <code>rts</code> function:</p>
<pre class="r"><code># Extract the year
MOD.getYear&lt;-function(x) 
  as.integer(sapply(x,FUN=function(x) substr(x,1,4)))

# Extract de julian day
MOD.getDOY&lt;-function(x) 
  as.integer(sapply(x,FUN=function(x) substr(x,5,7)))

# Process the MODIS-like date into YYYY-mm-dd format as Date object
MOD.getDate&lt;-function(x) 
  as.Date(sapply(x,FUN=function(x) as.character(as.Date(MOD.getDOY(x)-1,origin=paste(MOD.getYear(x),&quot;01-01&quot;,sep=&quot;-&quot;)))))

MODdates &lt;- MOD.getDate(MODISYrJday)

class(MODdates)</code></pre>
<pre><code>## [1] &quot;Date&quot;</code></pre>
<pre class="r"><code># Check the result for year 2012
print(MODdates[1:23])</code></pre>
<pre><code>##  [1] &quot;2012-01-01&quot; &quot;2012-01-17&quot; &quot;2012-02-02&quot; &quot;2012-02-18&quot; &quot;2012-03-05&quot;
##  [6] &quot;2012-03-21&quot; &quot;2012-04-06&quot; &quot;2012-04-22&quot; &quot;2012-05-08&quot; &quot;2012-05-24&quot;
## [11] &quot;2012-06-09&quot; &quot;2012-06-25&quot; &quot;2012-07-11&quot; &quot;2012-07-27&quot; &quot;2012-08-12&quot;
## [16] &quot;2012-08-28&quot; &quot;2012-09-13&quot; &quot;2012-09-29&quot; &quot;2012-10-15&quot; &quot;2012-10-31&quot;
## [21] &quot;2012-11-16&quot; &quot;2012-12-02&quot; &quot;2012-12-18&quot;</code></pre>
<p>With the dates vector (class <code>Date</code>) for each layer we can generate now make a raster time-series with <code>rts</code> constructor:</p>
<pre class="r"><code># Install the rts package
if(!(&quot;rts&quot; %in% installed.packages()[,1]))
  install.packages(c(&quot;rts&quot;), dependencies = TRUE)

library(rts)

rstTS &lt;- rts(rst, MODdates)</code></pre>
</div>
<div id="subsetting-raster-time-series" class="section level3">
<h3>Subsetting raster time-series</h3>
<hr />
<p>With the <code>RasterBrickTS</code> object created we can extract subsets of the data for particular periods or dates (check <code>?rts::subset</code> for more details):</p>
<pre class="r"><code># Subset a specific period
rstTSsubset1 &lt;- subset(rstTS,&quot;2013-05-15/2014-08-25&quot;)

# Subset the whole year of 2012
rstTSsubset2 &lt;- subset(rstTS,&quot;2012&quot;)

# Subset years from 2013 to 2014
rstTSsubset3 &lt;- subset(rstTS,&quot;2013/2014&quot;)

# Subset all years from (and including) 2014 to the series end
rstTSsubset4 &lt;- subset(rstTS,&quot;2014/&quot;)

# Subset all to the end of 2014
rstTSsubset5 &lt;- subset(rstTS,&quot;/2014&quot;)

# Subset all to the end of July 2014
rstTSsubset6 &lt;- subset(rstTS,&quot;/2014-06&quot;)

# Subset a specific month
rstTSsubset7 &lt;- subset(rstTS,&quot;2016-05&quot;)

# Plot the May 2016 data
plot(rstTSsubset7)</code></pre>
<div class="figure">
<img src="https://raw.githubusercontent.com/joaofgoncalves/R_exercises_raster_tutorial/master/img/P5_rasterTS_subset-1.png" />

</div>
<p>As you can see the <code>subset</code> function is pretty handy for extracting parts of a time-series. The date parameter format must left-specified with respect to the standard ISO:8601 time format ‚ÄúCCYY-MM-DD HH:MM:SS‚Äù. It is also possible to specify a range of times via the index-based subsetting, using ISO-recommended ‚Äú/‚Äù as the range operator. Generally it works with ‚Äúfrom/to‚Äù dates, where using both is optional. If one side is missing, it is interpreted as a request to retrieve layers from the beginning, or through the end of the raster time series.</p>
</div>
<div id="apply-functions-over-the-time-series" class="section level3">
<h3>Apply functions over the time-series</h3>
<hr />
<p>One of the best application of the <code>rts</code> package for processing raster time-series is the ability to apply a specified function to distinct periods. Let‚Äôs see how we can do this:</p>
<pre class="r"><code># Apply function to each quarter
# Mean
rstTS_quarterlyMN &lt;- apply.quarterly(rstTS, FUN = mean, na.rm=TRUE)
# Standard-deviation
rstTS_quarterlySD &lt;- apply.quarterly(rstTS, FUN = sd, na.rm=TRUE)

# Apply function to each year
# Mean
rstTS_yearlyMN &lt;- apply.yearly(rstTS, FUN = mean, na.rm=TRUE)
# Standard-deviation
rstTS_yearlySD &lt;- apply.yearly(rstTS, FUN = sd, na.rm=TRUE)

# Plot the time-series for annual EVI
plot(rstTS_yearlyMN)</code></pre>
<div class="figure">
<img src="https://raw.githubusercontent.com/joaofgoncalves/R_exercises_raster_tutorial/master/img/P5_rts_apply_family-1.png" />

</div>
<p>As we can see, these functions can be very useful for applying specific functions over certain calendar periods without the hassle of having to specify indices - you simply work with dates which is nicer! üëç üòâ</p>
<p>However in certain cases you may want to work with the ‚Äúsimpler‚Äù / more general functions that the <code>raster</code> package offers to apply functions over a raster time-series. In that case <code>calc</code> and <code>stackApply</code> can be used.</p>
<p>The difference between these functions is that <code>calc</code> applies the defined function over the whole series pixel-by-pixel while <code>stack</code> applies a function on subsets of a <code>RasterStack</code> or <code>RasterBrick</code>. For this function, the layers to be combined are indicated by an integer vector with indices. The function used should return a single value, and the number of layers in the output <code>Raster*</code> equals the number of unique values in indices. In the opposite hand, <code>calc</code> allows to have a function that outputs multiple values and, in that case, a multi-layer <code>Raster*</code> object is returned with one layer per output value.</p>
<p>Also, keep in mind that for large objects <code>calc</code> will compute values chunk by chunk. This means that for the result of fun to be correct it should not depend on having access to <em>all</em> values at once. Let‚Äôs grab some examples.</p>
<p>Using the <code>calc</code> function to provide a global average and standard-deviation of the entire raster time-series:</p>
<pre class="r"><code>rstMean &lt;- calc(rst, fun = mean)

rstStd &lt;- calc(rst, fun = sd)</code></pre>
<p>Now, let‚Äôs use <code>calc</code> for a multi-value output with a specific function:</p>
<pre class="r"><code># Calculate quantiles
# NOTE: you have to use na.rm=TRUE to make this work
rstQuantiles &lt;- calc(rst, fun = function(x,...) as.numeric(quantile(x,probs=c(0.05, 0.5, 0.95),...)), na.rm=TRUE)

print(rstQuantiles)</code></pre>
<pre><code>## class       : RasterBrick 
## dimensions  : 186, 179, 33294, 3  (nrow, ncol, ncell, nlayers)
## resolution  : 250, 250  (x, y)
## extent      : 549486, 594236, 4613206, 4659706  (xmin, xmax, ymin, ymax)
## coord. ref. : +proj=utm +zone=29 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0 
## data source : in memory
## names       : layer.1, layer.2, layer.3 
## min values  :  -290.7,    13.0,   271.5 
## max values  :  4229.3,  5572.0,  7458.0</code></pre>
<p><em>Et voil√†!</em> ‚ùï We have three layers, one for each calculated quantile.</p>
<p>Now, switching for <code>stackApply</code> we will emulate the behavior of rts <code>apply.yearly</code> function:</p>
<pre class="r"><code>rstYrMean &lt;- stackApply(rst, fun=mean, indices = rep(1:5,each=23))</code></pre>
<p>Well‚Ä¶ To be honest I was not aware of this but, strangely <code>rts</code> function took much more time to calculate the annual averages‚Ä¶ Check out the comparison below:</p>
<pre class="r"><code># stackApply with RasterBrick
system.time({rstYrMean &lt;- stackApply(rst, fun=mean, indices = rep(1:5,each=23))})</code></pre>
<pre><code>##    user  system elapsed 
##    0.52    0.04    0.58</code></pre>
<pre class="r"><code># apply.yearly with RasterBrickTS
system.time({rstTS_yearlyMN &lt;- apply.yearly(rstTS, FUN = mean, na.rm=TRUE)})</code></pre>
<pre><code>##    user  system elapsed 
##   23.47    1.25   24.75</code></pre>
<p>Let‚Äôs check if the data is equal to be sure:</p>
<pre class="r"><code>for(i in 1:nlayers(rstYrMean))
  print(compareRaster(rstYrMean[[i]], rstTS_yearlyMN@raster[[i]], values=TRUE))</code></pre>
<pre><code>## [1] TRUE
## [1] TRUE
## [1] TRUE
## [1] TRUE
## [1] TRUE</code></pre>
<p>Yup, all the layers are equal‚Ä¶<br />
Not sure why this is happening though‚Ä¶ ü§î. Do you have some idea / comment on this?</p>
<p>This concludes our exploration of the raster and the rts packages for this post. We have covered a couple of useful things for processing raster time-series. Hope you find it useful! üòÑ üëç üëç</p>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
